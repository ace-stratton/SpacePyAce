
# python wrapper for package gitlab.endurosatlab.com/ground_station/go-comms/pkg/gs within overall package pygs
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy.exe build -build-tags=dbg_log with_wire_only -no-make -output=art\spacepy-windows-amd64 .\pygs ..\pkg\gs ..\pkg\consts ..\pkg\misc ..\internal\event_notifier

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _pygs
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pygs import gs
# and then refer to everything using gs. prefix
# packages imported by this package listed below:

from . import consts



# ---- Types ---

# Python type for slice []*yaml.Node
class Slice_Ptr_yaml_Node(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.Slice_Ptr_yaml_Node_CTor()
			_pygs.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_yaml_Node.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		s = 'gs.Slice_Ptr_yaml_Node len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gs.Slice_Ptr_yaml_Node([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pygs.Slice_Ptr_yaml_Node_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pygs.Slice_Ptr_yaml_Node_len(self.handle)
				return Slice_Ptr_yaml_Node(handle=_pygs.Slice_Ptr_yaml_Node_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_yaml_Node(handle=_pygs.Slice_Ptr_yaml_Node_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pygs.Slice_Ptr_yaml_Node_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_yaml_Node.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_yaml_Node(handle=_pygs.Slice_Ptr_yaml_Node_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pygs.Slice_Ptr_yaml_Node_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []yaml_config.Option
class Slice_yaml_config_Option(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.Slice_yaml_config_Option_CTor()
			_pygs.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_yaml_config_Option.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		s = 'gs.Slice_yaml_config_Option len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gs.Slice_yaml_config_Option([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pygs.Slice_yaml_config_Option_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pygs.Slice_yaml_config_Option_len(self.handle)
				return Slice_yaml_config_Option(handle=_pygs.Slice_yaml_config_Option_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.yaml_config_Option(handle=_pygs.Slice_yaml_config_Option_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pygs.Slice_yaml_config_Option_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_yaml_config_Option.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.yaml_config_Option(handle=_pygs.Slice_yaml_config_Option_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pygs.Slice_yaml_config_Option_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct gs.Conn
class Conn(go.GoClass):
	"""A (protocol) connection to a module, which can be used to read and write data.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_Conn_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Conn{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Conn ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Subscribe(self, onNotify):
		"""Subscribe(object onNotify) str
		
		Subscribe to notifications without data.
		Not thread safe.
		"""
		return _pygs.gs_Conn_Subscribe(self.handle, onNotify.handle)
	def Unsubscribe(self):
		"""Unsubscribe() str
		
		Unsubscribe from notifications.
		Not thread safe.
		"""
		return _pygs.gs_Conn_Unsubscribe(self.handle)
	def SubscribeData(self, onNotify):
		"""SubscribeData(object onNotify) str
		
		Subscribe to data notifications.
		Not thread safe.
		"""
		return _pygs.gs_Conn_SubscribeData(self.handle, onNotify.handle)
	def UnsubscribeData(self):
		"""UnsubscribeData() str
		
		Unsubscribe from data notifications.
		Not thread safe.
		"""
		return _pygs.gs_Conn_UnsubscribeData(self.handle)
	def SubscribeFrame(self, onNotify):
		"""SubscribeFrame(object onNotify) str
		
		Subscribe to per-frame notifications.
		Not thread safe.
		"""
		return _pygs.gs_Conn_SubscribeFrame(self.handle, onNotify.handle)
	def UnsubscribeFrame(self):
		"""UnsubscribeFrame() str
		
		Unsubscribe from per-frame notifications.
		Not thread safe.
		"""
		return _pygs.gs_Conn_UnsubscribeFrame(self.handle)
	def Read(self, data):
		"""Read(object data) str err
		
		Read data.
		Not thread safe.
		"""
		return _pygs.gs_Conn_Read(self.handle, data.handle)
	def Write(self, data):
		"""Write([]int data) str err
		
		Write data.
		Not thread safe.
		"""
		return _pygs.gs_Conn_Write(self.handle, data.handle)
	def Cancel(self, goRun=False):
		"""Cancel() 
		
		Sends a cancel request to the datalink connection.
		The connection will return cancelled error on the next frame read or write.
		Thread safe.
		"""
		_pygs.gs_Conn_Cancel(self.handle, goRun)
	def Close(self, goRun=False):
		"""Close() 
		
		Close the (protocol) connection.
		Not thread safe.
		"""
		_pygs.gs_Conn_Close(self.handle, goRun)

# Python type for struct gs.DataNotify
class DataNotify(go.GoClass):
	"""Data notify callback function.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_DataNotify_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.DataNotify{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.DataNotify ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct gs.FrameNotify
class FrameNotify(go.GoClass):
	"""Frame notify callback function.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_FrameNotify_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.FrameNotify{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.FrameNotify ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct gs.FrameResult
class FrameResult(go.GoClass):
	"""Frame notify result.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_FrameResult_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.LocalAddr = args[0]
			if "LocalAddr" in kwargs:
				self.LocalAddr = kwargs["LocalAddr"]
			if  1 < len(args):
				self.RemoteAddr = args[1]
			if "RemoteAddr" in kwargs:
				self.RemoteAddr = kwargs["RemoteAddr"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  3 < len(args):
				self.IsRead = args[3]
			if "IsRead" in kwargs:
				self.IsRead = kwargs["IsRead"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.FrameResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.FrameResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LocalAddr(self):
		return _pygs.gs_FrameResult_LocalAddr_Get(self.handle)
	@LocalAddr.setter
	def LocalAddr(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_FrameResult_LocalAddr_Set(self.handle, value.handle)
		else:
			_pygs.gs_FrameResult_LocalAddr_Set(self.handle, value)
	@property
	def RemoteAddr(self):
		return _pygs.gs_FrameResult_RemoteAddr_Get(self.handle)
	@RemoteAddr.setter
	def RemoteAddr(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_FrameResult_RemoteAddr_Set(self.handle, value.handle)
		else:
			_pygs.gs_FrameResult_RemoteAddr_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_pygs.gs_FrameResult_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_FrameResult_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IsRead(self):
		return _pygs.gs_FrameResult_IsRead_Get(self.handle)
	@IsRead.setter
	def IsRead(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_FrameResult_IsRead_Set(self.handle, value.handle)
		else:
			_pygs.gs_FrameResult_IsRead_Set(self.handle, value)

# Python type for struct gs.GS
class GS(go.GoClass):
	"""A ground station. Holds default configurations, which will be used for the connections. They can be overridden.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_GS_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GS{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GS ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ConfigUnmarshaler(self):
		"""ConfigUnmarshaler() object
		
		Get the current GS configuration.
		"""
		return go.util_ConfigUnmarshaler(handle=_pygs.gs_GS_ConfigUnmarshaler(self.handle))
	def Dial(self, remoteAddrString, *args):
		"""Dial(str remoteAddrString, []object options) object conn, str err
		
		Dial a connection using multi-address to setup arbitrary protocol layers.
		The local address is configurable.
		Options replace the current GS configuration, so if you wish to override just
		some GS options, make sure to first add WithGS().
		Not thread safe.
		"""
		options = Slice_yaml_config_Option(args)
		return Conn(handle=_pygs.gs_GS_Dial(self.handle, remoteAddrString, options.handle))
	def Listen(self, localAddrString, *args):
		"""Listen(str localAddrString, []object options) object listener, str err"""
		options = Slice_yaml_config_Option(args)
		return Listener(handle=_pygs.gs_GS_Listen(self.handle, localAddrString, options.handle))
	def RotatorSetPosition(self, pos, notifyPos):
		"""RotatorSetPosition(object pos, callable notifyPos) str err
		
		Command a ground station antenna rotator.
		"""
		return _pygs.gs_GS_RotatorSetPosition(self.handle, pos.handle, notifyPos)

# Python type for struct gs.Listener
class Listener(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_Listener_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Listener{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Listener ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Accept(self):
		"""Accept() object conn, str err"""
		return Conn(handle=_pygs.gs_Listener_Accept(self.handle))

# Python type for struct gs.DataResult
class DataResult(go.GoClass):
	"""Data notify result.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_DataResult_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  1 < len(args):
				self.DataOffset = args[1]
			if "DataOffset" in kwargs:
				self.DataOffset = kwargs["DataOffset"]
			if  2 < len(args):
				self.DataWholeSize = args[2]
			if "DataWholeSize" in kwargs:
				self.DataWholeSize = kwargs["DataWholeSize"]
			if  3 < len(args):
				self.IsRead = args[3]
			if "IsRead" in kwargs:
				self.IsRead = kwargs["IsRead"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.DataResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.DataResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_byte(handle=_pygs.gs_DataResult_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_DataResult_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DataOffset(self):
		return _pygs.gs_DataResult_DataOffset_Get(self.handle)
	@DataOffset.setter
	def DataOffset(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_DataResult_DataOffset_Set(self.handle, value.handle)
		else:
			_pygs.gs_DataResult_DataOffset_Set(self.handle, value)
	@property
	def DataWholeSize(self):
		return _pygs.gs_DataResult_DataWholeSize_Get(self.handle)
	@DataWholeSize.setter
	def DataWholeSize(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_DataResult_DataWholeSize_Set(self.handle, value.handle)
		else:
			_pygs.gs_DataResult_DataWholeSize_Set(self.handle, value)
	@property
	def IsRead(self):
		return _pygs.gs_DataResult_IsRead_Get(self.handle)
	@IsRead.setter
	def IsRead(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_DataResult_IsRead_Set(self.handle, value.handle)
		else:
			_pygs.gs_DataResult_IsRead_Set(self.handle, value)

# Python type for struct gs.GSConfigStruct
class GSConfigStruct(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_GSConfigStruct_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.Addresses = args[0]
			if "Addresses" in kwargs:
				self.Addresses = kwargs["Addresses"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GSConfigStruct{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GSConfigStruct ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Addresses(self):
		return consts.AddressMap(handle=_pygs.gs_GSConfigStruct_Addresses_Get(self.handle))
	@Addresses.setter
	def Addresses(self, value):
		if isinstance(value, go.GoClass):
			_pygs.gs_GSConfigStruct_Addresses_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct gs.GSConfig
class GSConfig(GSConfigStruct):
	"""GS configuration.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_GSConfig_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GSConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.GSConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct gs.Notify
class Notify(go.GoClass):
	"""Notify callback function.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.gs_Notify_CTor()
			_pygs.IncRef(self.handle)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Notify{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gs.Notify ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewGS(*args):
	"""NewGS([]object options) object g, str err
	
	Create a new "ground station" with config options.
	Not thread safe.
	"""
	options = Slice_yaml_config_Option(args)
	return GS(handle=_pygs.gs_NewGS(options.handle))


# ---- Functions ---
def WithCommZMQ(dnLink, upLink, dnLinkTimeout, upLinkTimeout):
	"""WithCommZMQ(str dnLink, str upLink, str dnLinkTimeout, str upLinkTimeout) object
	
	Configure with specific ZeroMQ device
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommZMQ(dnLink, upLink, dnLinkTimeout, upLinkTimeout))
def Version():
	"""Version() str
	
	Get the version set during build.
	"""
	return _pygs.gs_Version()
def WithCommNodeZMQ(optionsVar):
	"""WithCommNodeZMQ(str optionsVar) object
	
	Configure with specific node ZeroMQ device
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommNodeZMQ(optionsVar))
def WithCommWebSerial(portVar, optionsVar):
	"""WithCommWebSerial(str portVar, str optionsVar) object
	
	Configure with specific web serial device.
	Check https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API for further info on Web Serial.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommWebSerial(portVar, optionsVar))
def WithCommNodeSerial(optionsVar):
	"""WithCommNodeSerial(str optionsVar) object
	
	Configure with specific node serial device.
	Check https://github.com/serialport/node-serialport for further info on Node Serialport.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommNodeSerial(optionsVar))
def WithTPOneWay(isOneWay):
	"""WithTPOneWay(bool isOneWay) object
	
	Configure TP protocol with one-way option
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithTPOneWay(isOneWay))
def WithAirConn(remoteRadioMac, gsId):
	"""WithAirConn(int remoteRadioMac, long gsId) object
	
	Configure with specific AirMac/UHFGw connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAirConn(remoteRadioMac, gsId))
def WithAmacConn(protoId):
	"""WithAmacConn(int protoId) object
	
	Configure with specific AirMac connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAmacConn(protoId))
def WithCSPConnLess():
	"""WithCSPConnLess() object
	
	Configure with CSP connection-less transport
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCSPConnLess())
def WithFWUpdBundle(SubModule, ModuleType, ModuleConfig, BoardRevision, CPUType, FWType, FWVerMaj, FWVerMin, Flags):
	"""WithFWUpdBundle(int SubModule, int ModuleType, int ModuleConfig, int BoardRevision, int CPUType, int FWType, int FWVerMaj, int FWVerMin, long Flags) object
	
	Configure with specific FWUpd bundle options.
	This should be used when writing binary file/firmware payloads.
	ES modules expect these parameters prepended to the payload, so if they aren't already bundled
	with it they should be provided to the connection through this functional option.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithFWUpdBundle(SubModule, ModuleType, ModuleConfig, BoardRevision, CPUType, FWType, FWVerMaj, FWVerMin, Flags))
def WithGSConfig(addresses):
	"""WithGSConfig(object addresses) object
	
	Configure with specific space separated GS local multi addresses
	e.g. "esmgw" => 1, "esgnur/esamac" => 0, etc.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithGSConfig(addresses.handle))
def WithMacConn(macProtoId):
	"""WithMacConn(int macProtoId) object
	
	Configure with specific Mac connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithMacConn(macProtoId))
def WithCSP(comm, address, hostname, model, revision, connMax, connQueueLen, fifoLen, portMaxBind, rdpMaxWindow, buffers, bufferDataSize, connDefOpt):
	"""WithCSP(str comm, long address, str hostname, str model, str revision, int connMax, int connQueueLen, int fifoLen, int portMaxBind, int rdpMaxWindow, int buffers, int bufferDataSize, long connDefOpt) object
	
	Configure with specific CSP protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCSP(comm, address, hostname, model, revision, connMax, connQueueLen, fifoLen, portMaxBind, rdpMaxWindow, buffers, bufferDataSize, connDefOpt))
def WithCSPConn(prio, readTimeout, writeTimeout, opts):
	"""WithCSPConn(int prio, str readTimeout, str writeTimeout, long opts) object
	
	Configure with specific CSP connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCSPConn(prio, readTimeout, writeTimeout, opts))
def WithGnur(comm):
	"""WithGnur(str comm) object
	
	Configure with specific GNUR protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithGnur(comm))
def WithMac(comm):
	"""WithMac(str comm) object
	
	Configure with specific Mac protocol options
	An example case of the usage of this function would be if you're communicating with an
	EnduroSat payload computer module. We have a specific mac driver for communication by
	wire there and this option could be used to configure the comms with the module.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithMac(comm))
def WithMacDg(comm):
	"""WithMacDg(str comm) object
	
	Configure with specific MacDongle options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithMacDg(comm))
def Build():
	"""Build() str
	
	Get the build number and time set during build.
	"""
	return _pygs.gs_Build()
def WithAir(sessionTimeout):
	"""WithAir(str sessionTimeout) object
	
	Configure with specific AirMac/UHFGw protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAir(sessionTimeout))
def WithCPConn(cmdId, cmdType, cpTripType):
	"""WithCPConn(long cmdId, long cmdType, int cpTripType) object
	
	Configure with specific CP protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCPConn(cmdId, cmdType, cpTripType))
def WithRFCfg(writeTimeout):
	"""WithRFCfg(str writeTimeout) object
	
	Configure with specific RF options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithRFCfg(writeTimeout))
def WithRotator(rotator):
	"""WithRotator(str rotator) object
	
	Configure with specific GS rotator configuration
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithRotator(rotator))
def WithRotatorProsistelD(name, baud):
	"""WithRotatorProsistelD(str name, int baud) object
	
	Configure with specific ProsisTel D rotator configuration
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithRotatorProsistelD(name, baud))
def WithAX25Encryption(isEncrypted, aesKey, aesIV):
	"""WithAX25Encryption(bool isEncrypted, str aesKey, str aesIV) object
	
	Configure with AX25 encryption
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAX25Encryption(isEncrypted, aesKey, aesIV))
def WithFile(val):
	"""WithFile(str val) object
	
	Configure with yaml filename
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithFile(val))
def WithTP(readDataTimeout, writeDataTimeout, minWriteBurstSize, maxWriteBurstSize):
	"""WithTP(str readDataTimeout, str writeDataTimeout, int minWriteBurstSize, int maxWriteBurstSize) object
	
	Configure with specific TP protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithTP(readDataTimeout, writeDataTimeout, minWriteBurstSize, maxWriteBurstSize))
def WithGS(val):
	"""WithGS(object val) object
	
	Configure from an existing GS instance
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithGS(val.handle))
def WithMacGWConn(macProtoId):
	"""WithMacGWConn(int macProtoId) object
	
	Configure with specific MacGateway connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithMacGWConn(macProtoId))
def WithUhfGWConn(cmd):
	"""WithUhfGWConn(int cmd) object
	
	Configure with specific UhfGW connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithUhfGWConn(cmd))
def WithAmacCmac(hasCmac, cmacKey):
	"""WithAmacCmac(bool hasCmac, str cmacKey) object
	
	Configure with CBC-MAC message authentication. This will prepend random IVs with each message and DefaultAesIV will be ignored.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAmacCmac(hasCmac, cmacKey))
def WithAmacEncryption(aesKey, defaultAesIV):
	"""WithAmacEncryption(str aesKey, str defaultAesIV) object
	
	Configure with specific AirMac protocol AES options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAmacEncryption(aesKey, defaultAesIV))
def WithCommSerial(name, baud, readTimeout):
	"""WithCommSerial(str name, int baud, str readTimeout) object
	
	Configure with specific serial device
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommSerial(name, baud, readTimeout))
def WithTPConn(tpProtoId, packetId, hostContext):
	"""WithTPConn(int tpProtoId, long packetId, long hostContext) object
	
	Configure with specific TP connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithTPConn(tpProtoId, packetId, hostContext))
def WithAirOneWay(isOneWay):
	"""WithAirOneWay(bool isOneWay) object
	
	Configure Air protocols with one-way option
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithAirOneWay(isOneWay))
def WithGSConn(readTimeout, writeTimeout, noProgressTimeout, maxReadBurstTimeout, maxWriteBurstTimeout, maxBurstSize):
	"""WithGSConn(str readTimeout, str writeTimeout, str noProgressTimeout, str maxReadBurstTimeout, str maxWriteBurstTimeout, int maxBurstSize) object
	
	Configure with specific GS connection configuration
	Any options set here (timeouts, burst sizes, etc.) are global for the whole GS instance, meaning they are definitive and aren't a subject of change
	by anything from within the connection. As an example - if a write timeout, set through this function, expires the GS instance will return the connection
	immediately.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithGSConn(readTimeout, writeTimeout, noProgressTimeout, maxReadBurstTimeout, maxWriteBurstTimeout, maxBurstSize))
def WithGnurConn(protoId):
	"""WithGnurConn(int protoId) object
	
	Configure with specific GNUR connection options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithGnurConn(protoId))
def WithMacGW(baseSendPrio, intf):
	"""WithMacGW(int baseSendPrio, int intf) object
	
	Configure with specific MacGateway protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithMacGW(baseSendPrio, intf))
def WithString(val):
	"""WithString(str val) object
	
	Configure with yaml configuration passed as a string
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithString(val))
def WithCommMacDrv(name, readTimeout, baseSendPrio):
	"""WithCommMacDrv(str name, str readTimeout, int baseSendPrio) object
	
	Configure with specific Endurosat macDrv device.
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithCommMacDrv(name, readTimeout, baseSendPrio))
def WithFWUpdConn(cmd, isBundle, fileName):
	"""WithFWUpdConn(int cmd, bool isBundle, str fileName) object
	
	Configure with specific FWUpd protocol options
	"""
	return go.yaml_config_Option(handle=_pygs.gs_WithFWUpdConn(cmd, isBundle, fileName))


