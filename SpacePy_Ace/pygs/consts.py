
# python wrapper for package gitlab.endurosatlab.com/ground_station/go-comms/pkg/consts within overall package pygs
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy.exe build -build-tags=dbg_log with_wire_only -no-make -output=art\spacepy-windows-amd64 .\pygs ..\pkg\gs ..\pkg\consts ..\pkg\misc ..\internal\event_notifier

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _pygs
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pygs import consts
# and then refer to everything using consts. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for map map[uint8]error
class Map_uint8_error(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.Map_uint8_error_CTor()
			_pygs.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_uint8_error.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pygs.Map_uint8_error_set(self.handle, k, v)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		s = 'pygs.Map_uint8_error len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pygs.Map_uint8_error({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pygs.Map_uint8_error_len(self.handle)
	def __getitem__(self, key):
		return _pygs.Map_uint8_error_elem(self.handle, key)
	def __setitem__(self, key, value):
		_pygs.Map_uint8_error_set(self.handle, key, value)
	def __delitem__(self, key):
		return _pygs.Map_uint8_error_delete(self.handle, key)
	def keys(self):
		return go.Slice_uint8(handle=_pygs.Map_uint8_error_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pygs.Map_uint8_error_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class AirProtoId(Enum):
	"""
	The higher level protocol, which the Air Mac protocol encapsulates.
	
	"""
	AirProtoId_None = 0
	AirProtoId_Init = 1
	AirProtoId_Response = 2
	AirProtoId_TL = 3
	AirProtoId_Reset = 4
	AirProtoId_ChangeRadioFreq = 5
	AirProtoId_TextBegin = 32
	AirProtoId_TextEnd = 127

AirProtoId_None = 0
AirProtoId_Init = 1
AirProtoId_Response = 2
AirProtoId_TL = 3
AirProtoId_Reset = 4
AirProtoId_ChangeRadioFreq = 5
AirProtoId_TextBegin = 32
AirProtoId_TextEnd = 127

class CPTripType(Enum):
	"""
	The way command responses are returned.
	
	"""
	CPTripType_NoRes = 0
	CPTripType_ImmediateRes = 1
	CPTripType_PostponedRes = 2

CPTripType_NoRes = 0
CPTripType_ImmediateRes = 1
CPTripType_PostponedRes = 2

class DatalinkProto(Enum):
	"""
	The datalink (MAC) protocol.
	
	"""
	DatalinkProto_MacGW = 1
	DatalinkProto_Amac = 2
	DatalinkProto_UhfGW = 3
	DatalinkProto_Mac = 4
	DatalinkProto_Gnur = 5

DatalinkProto_MacGW = 1
DatalinkProto_Amac = 2
DatalinkProto_UhfGW = 3
DatalinkProto_Mac = 4
DatalinkProto_Gnur = 5

class FWUpdCmd(Enum):
	"""
	The type of a firmware update command.
	
	"""
	FWUpdCmd_Upload = 0
	FWUpdCmd_Status = 1
	FWUpdCmd_Update = 2

FWUpdCmd_Upload = 0
FWUpdCmd_Status = 1
FWUpdCmd_Update = 2

class FWUpdFlag(Enum):
	"""
	The flags of a firmware update.
	
	"""
	FWUpdFlag_None = 0
	FWUpdFlag_Installed = 1
	FWUpdFlag_Encrypted = 2
	FWUpdFlag_Archived = 4
	FWUpdFlag_Healthy = 8
	FWUpdFlag_Downloaded = 16
	FWUpdFlag_Install_Pending = 32
	FWUpdFlag_File_Safe_App = 64
	FWUpdFlag_File_Tle = 128
	FWUpdFlag_Payload_Schedule = 256
	FWUpdFlag_File_Zip = 512
	FWUpdFlag_File_Cmd = 1024

FWUpdFlag_None = 0
FWUpdFlag_Installed = 1
FWUpdFlag_Encrypted = 2
FWUpdFlag_Archived = 4
FWUpdFlag_Healthy = 8
FWUpdFlag_Downloaded = 16
FWUpdFlag_Install_Pending = 32
FWUpdFlag_File_Safe_App = 64
FWUpdFlag_File_Tle = 128
FWUpdFlag_Payload_Schedule = 256
FWUpdFlag_File_Zip = 512
FWUpdFlag_File_Cmd = 1024

class FWUpdStatus(Enum):
	"""
	The status of a firmware update.
	
	"""
	FWUpdStatus_NoFile = 0
	FWUpdStatus_Pending = 1
	FWUpdStatus_Invalid = 2
	FWUpdStatus_Completed = 3

FWUpdStatus_NoFile = 0
FWUpdStatus_Pending = 1
FWUpdStatus_Invalid = 2
FWUpdStatus_Completed = 3

class GnurProtoId(Enum):
	"""
	The type of a GNUR protocol ID.
	
	"""
	GnurProtoId_None = 0
	GnurProtoId_ChangeRadioFreq = 1
	GnurProtoId_SendAmacFrame = 2

GnurProtoId_None = 0
GnurProtoId_ChangeRadioFreq = 1
GnurProtoId_SendAmacFrame = 2

class MacGWIntf(Enum):
	"""
	The MAC gateway protocol specific interface.
	
	"""
	MacGWIntf_Sys_Pri = 0
	MacGWIntf_Sys_Sec = 1
	MacGWIntf_Pay_Pri = 2
	MacGWIntf_Pay_sec = 3

MacGWIntf_Sys_Pri = 0
MacGWIntf_Sys_Sec = 1
MacGWIntf_Pay_Pri = 2
MacGWIntf_Pay_sec = 3

class MacPrio(Enum):
	MacPrio_Critical = 1
	MacPrio_TQ = 1
	MacPrio_High = 3
	MacPrio_TQSpan = 6
	MacPrio_Normal = 7
	MacPrio_Low = 13

MacPrio_Critical = 1
MacPrio_TQ = 1
MacPrio_High = 3
MacPrio_TQSpan = 6
MacPrio_Normal = 7
MacPrio_Low = 13

class MacProtoId(Enum):
	"""
	The higher level protocol, which the Mac protocol encapsulates.
	
	"""
	MacProtoId_None = 0
	MacProtoId_FWUpd = 2
	MacProtoId_NetDebug = 3
	MacProtoId_Diagnostics = 4
	MacProtoId_UHF = 5
	MacProtoId_LED = 6
	MacProtoId_Debug = 7
	MacProtoId_EPSI = 10
	MacProtoId_TP = 11
	MacProtoId_FP = 12
	MacProtoId_Service = 13
	MacProtoId_MACTest = 255

MacProtoId_None = 0
MacProtoId_FWUpd = 2
MacProtoId_NetDebug = 3
MacProtoId_Diagnostics = 4
MacProtoId_UHF = 5
MacProtoId_LED = 6
MacProtoId_Debug = 7
MacProtoId_EPSI = 10
MacProtoId_TP = 11
MacProtoId_FP = 12
MacProtoId_Service = 13
MacProtoId_MACTest = 255

class ModuleTypeId(Enum):
	"""
	The type of a module.
	
	"""
	ModuleTypeId_Unknown = 0
	ModuleTypeId_MSPMacGatewayDev = 1
	ModuleTypeId_EPSII_PDM = 2
	ModuleTypeId_EPSII_BP = 3
	ModuleTypeId_EPSII_BPL = 4
	ModuleTypeId_OBC1016 = 5
	ModuleTypeId_OBC2 = 6
	ModuleTypeId_UHF2 = 7
	ModuleTypeId_EPS_I = 8
	ModuleTypeId_SBAND_TMTC = 9
	ModuleTypeId_MAX = 10

ModuleTypeId_Unknown = 0
ModuleTypeId_MSPMacGatewayDev = 1
ModuleTypeId_EPSII_PDM = 2
ModuleTypeId_EPSII_BP = 3
ModuleTypeId_EPSII_BPL = 4
ModuleTypeId_OBC1016 = 5
ModuleTypeId_OBC2 = 6
ModuleTypeId_UHF2 = 7
ModuleTypeId_EPS_I = 8
ModuleTypeId_SBAND_TMTC = 9
ModuleTypeId_MAX = 10

class RFConfigMode(Enum):
	"""
	RFConfig GFSK/GMSK mode, defining the baud rate and the frequency deviation.
	
	"""
	RFConfigMode_1200_600 = 0
	RFConfigMode_2400_600 = 1
	RFConfigMode_4800_1200 = 2
	RFConfigMode_9600_2400 = 3
	RFConfigMode_9600_4800 = 4
	RFConfigMode_19200_4800 = 5
	RFConfigMode_19200_9600 = 6
	RFConfigMode_19200_19200 = 7

RFConfigMode_1200_600 = 0
RFConfigMode_2400_600 = 1
RFConfigMode_4800_1200 = 2
RFConfigMode_9600_2400 = 3
RFConfigMode_9600_4800 = 4
RFConfigMode_19200_4800 = 5
RFConfigMode_19200_9600 = 6
RFConfigMode_19200_19200 = 7

class RFConfigRadioMode(Enum):
	"""
	The radio mode.
	
	"""
	RFConfigRadioMode_Sleep = 0
	RFConfigRadioMode_TX = 1
	RFConfigRadioMode_RX = 2

RFConfigRadioMode_Sleep = 0
RFConfigRadioMode_TX = 1
RFConfigRadioMode_RX = 2

class RFConfigType(Enum):
	"""
	RFConfig protocol type
	
	"""
	RFConfigType_Init = 1
	RFConfigType_ChangeUHFFreq = 2
	RFConfigType_ChangeRadioMode = 3
	RFConfigType_ChangeAESKey = 4
	RFConfigType_ChangeFreq = 5
	RFConfigType_End = 6

RFConfigType_Init = 1
RFConfigType_ChangeUHFFreq = 2
RFConfigType_ChangeRadioMode = 3
RFConfigType_ChangeAESKey = 4
RFConfigType_ChangeFreq = 5
RFConfigType_End = 6

class SubModuleId(Enum):
	"""
	FW update sub-module IDs.
	
	"""
	SubModuleId_ModuleFWUpd = 0
	SubModuleId_PayloadFWUpd = 1
	SubModuleId_FileUpload = 2

SubModuleId_ModuleFWUpd = 0
SubModuleId_PayloadFWUpd = 1
SubModuleId_FileUpload = 2

class TPProtoId(Enum):
	"""
	The higher level protocol, which the TP protocol encapsulates.
	
	"""
	TPProtoId_CP = 10
	TPProtoId_FWUpd = 14

TPProtoId_CP = 10
TPProtoId_FWUpd = 14

class UhfGWCmd(Enum):
	"""
	The type of a UHF GW command.
	
	"""
	UhfGWCmd_None = 0
	UhfGWCmd_TunOut = 1
	UhfGWCmd_TunIn = 2
	UhfGWCmd_AsyncErr = 3
	UhfGWCmd_InitRadio = 4
	UhfGWCmd_ChangeRadioMode = 5
	UhfGWCmd_TunInAx25 = 6
	UhfGWCmd_ChangeRadioFreq = 7
	UhfGWCmd_ChangeAESKey = 8

UhfGWCmd_None = 0
UhfGWCmd_TunOut = 1
UhfGWCmd_TunIn = 2
UhfGWCmd_AsyncErr = 3
UhfGWCmd_InitRadio = 4
UhfGWCmd_ChangeRadioMode = 5
UhfGWCmd_TunInAx25 = 6
UhfGWCmd_ChangeRadioFreq = 7
UhfGWCmd_ChangeAESKey = 8



#---- Constants from Go: Python can only ask that you please don't change these! ---
EESTL_SFERR_RECOVERABLE_MARGIN = 100


# ---- Global Variables: can only use functions to access ---
def FwUpdError():
	"""
	FwUpdError Gets Go Variable: consts.FwUpdError
	A map of FW update errors.
	
	"""
	return Map_uint8_error(handle=_pygs.consts_FwUpdError())

def Set_FwUpdError(value):
	"""
	Set_FwUpdError Sets Go Variable: consts.FwUpdError
	A map of FW update errors.
	
	"""
	if isinstance(value, go.GoClass):
		_pygs.consts_Set_FwUpdError(value.handle)
	else:
		_pygs.consts_Set_FwUpdError(value)

def FwUpdStatus():
	"""
	FwUpdStatus Gets Go Variable: consts.FwUpdStatus
	A map of FW update status errors.
	
	"""
	return Map_uint8_error(handle=_pygs.consts_FwUpdStatus())

def Set_FwUpdStatus(value):
	"""
	Set_FwUpdStatus Sets Go Variable: consts.FwUpdStatus
	A map of FW update status errors.
	
	"""
	if isinstance(value, go.GoClass):
		_pygs.consts_Set_FwUpdStatus(value.handle)
	else:
		_pygs.consts_Set_FwUpdStatus(value)

def MacGWResErr():
	"""
	MacGWResErr Gets Go Variable: consts.MacGWResErr
	A map of MAC gateway errors.
	
	"""
	return Map_uint8_error(handle=_pygs.consts_MacGWResErr())

def Set_MacGWResErr(value):
	"""
	Set_MacGWResErr Sets Go Variable: consts.MacGWResErr
	A map of MAC gateway errors.
	
	"""
	if isinstance(value, go.GoClass):
		_pygs.consts_Set_MacGWResErr(value.handle)
	else:
		_pygs.consts_Set_MacGWResErr(value)

def TPError():
	"""
	TPError Gets Go Variable: consts.TPError
	A map of TP errors.
	
	"""
	return Map_uint8_error(handle=_pygs.consts_TPError())

def Set_TPError(value):
	"""
	Set_TPError Sets Go Variable: consts.TPError
	A map of TP errors.
	
	"""
	if isinstance(value, go.GoClass):
		_pygs.consts_Set_TPError(value.handle)
	else:
		_pygs.consts_Set_TPError(value)

def UhfGWResErr():
	"""
	UhfGWResErr Gets Go Variable: consts.UhfGWResErr
	A map of UHF GW errors.
	
	"""
	return Map_uint8_error(handle=_pygs.consts_UhfGWResErr())

def Set_UhfGWResErr(value):
	"""
	Set_UhfGWResErr Sets Go Variable: consts.UhfGWResErr
	A map of UHF GW errors.
	
	"""
	if isinstance(value, go.GoClass):
		_pygs.consts_Set_UhfGWResErr(value.handle)
	else:
		_pygs.consts_Set_UhfGWResErr(value)



# ---- Interfaces ---


# ---- Structs ---

# Python type for struct consts.RFConfigHeader
class RFConfigHeader(go.GoClass):
	"""RFConfig protocol header\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.consts_RFConfigHeader_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  1 < len(args):
				self.DownlinkFreq = args[1]
			if "DownlinkFreq" in kwargs:
				self.DownlinkFreq = kwargs["DownlinkFreq"]
			if  2 < len(args):
				self.UplinkFreq = args[2]
			if "UplinkFreq" in kwargs:
				self.UplinkFreq = kwargs["UplinkFreq"]
			if  3 < len(args):
				self.RFMode = args[3]
			if "RFMode" in kwargs:
				self.RFMode = kwargs["RFMode"]
			if  4 < len(args):
				self.RadioMode = args[4]
			if "RadioMode" in kwargs:
				self.RadioMode = kwargs["RadioMode"]
			if  5 < len(args):
				self.IsIntFrac = args[5]
			if "IsIntFrac" in kwargs:
				self.IsIntFrac = kwargs["IsIntFrac"]
			if  6 < len(args):
				self.AESKeySize = args[6]
			if "AESKeySize" in kwargs:
				self.AESKeySize = kwargs["AESKeySize"]
			if  7 < len(args):
				self.Encrypted = args[7]
			if "Encrypted" in kwargs:
				self.Encrypted = kwargs["Encrypted"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RFConfigHeader{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RFConfigHeader ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _pygs.consts_RFConfigHeader_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_Type_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_Type_Set(self.handle, value)
	@property
	def DownlinkFreq(self):
		return _pygs.consts_RFConfigHeader_DownlinkFreq_Get(self.handle)
	@DownlinkFreq.setter
	def DownlinkFreq(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_DownlinkFreq_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_DownlinkFreq_Set(self.handle, value)
	@property
	def UplinkFreq(self):
		return _pygs.consts_RFConfigHeader_UplinkFreq_Get(self.handle)
	@UplinkFreq.setter
	def UplinkFreq(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_UplinkFreq_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_UplinkFreq_Set(self.handle, value)
	@property
	def RFMode(self):
		return _pygs.consts_RFConfigHeader_RFMode_Get(self.handle)
	@RFMode.setter
	def RFMode(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_RFMode_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_RFMode_Set(self.handle, value)
	@property
	def RadioMode(self):
		return _pygs.consts_RFConfigHeader_RadioMode_Get(self.handle)
	@RadioMode.setter
	def RadioMode(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_RadioMode_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_RadioMode_Set(self.handle, value)
	@property
	def IsIntFrac(self):
		return _pygs.consts_RFConfigHeader_IsIntFrac_Get(self.handle)
	@IsIntFrac.setter
	def IsIntFrac(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_IsIntFrac_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_IsIntFrac_Set(self.handle, value)
	@property
	def AESKeySize(self):
		return _pygs.consts_RFConfigHeader_AESKeySize_Get(self.handle)
	@AESKeySize.setter
	def AESKeySize(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_AESKeySize_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_AESKeySize_Set(self.handle, value)
	@property
	def Encrypted(self):
		return _pygs.consts_RFConfigHeader_Encrypted_Get(self.handle)
	@Encrypted.setter
	def Encrypted(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfigHeader_Encrypted_Set(self.handle, value.handle)
		else:
			_pygs.consts_RFConfigHeader_Encrypted_Set(self.handle, value)

# Python type for struct consts.RFConfig
class RFConfig(RFConfigHeader):
	"""RFConfig protocol for configuring a ground station radio\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.consts_RFConfig_CTor()
			_pygs.IncRef(self.handle)
			if  1 < len(args):
				self.AESKey = args[1]
			if "AESKey" in kwargs:
				self.AESKey = kwargs["AESKey"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RFConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RFConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AESKey(self):
		return go.Slice_byte(handle=_pygs.consts_RFConfig_AESKey_Get(self.handle))
	@AESKey.setter
	def AESKey(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RFConfig_AESKey_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Ser(self):
		"""Ser() []int
		
		Serialize a RFConfig packet to write to esrfcfg connection for initializing the radio.
		"""
		return go.Slice_byte(handle=_pygs.consts_RFConfig_Ser(self.handle))

# Python type for struct consts.RotatorPosition
class RotatorPosition(go.GoClass):
	"""Position represents the azimuth and elevation of a rotator.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.consts_RotatorPosition_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.Azimuth = args[0]
			if "Azimuth" in kwargs:
				self.Azimuth = kwargs["Azimuth"]
			if  1 < len(args):
				self.Elevation = args[1]
			if "Elevation" in kwargs:
				self.Elevation = kwargs["Elevation"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RotatorPosition{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.RotatorPosition ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Azimuth(self):
		return _pygs.consts_RotatorPosition_Azimuth_Get(self.handle)
	@Azimuth.setter
	def Azimuth(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RotatorPosition_Azimuth_Set(self.handle, value.handle)
		else:
			_pygs.consts_RotatorPosition_Azimuth_Set(self.handle, value)
	@property
	def Elevation(self):
		return _pygs.consts_RotatorPosition_Elevation_Get(self.handle)
	@Elevation.setter
	def Elevation(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_RotatorPosition_Elevation_Set(self.handle, value.handle)
		else:
			_pygs.consts_RotatorPosition_Elevation_Set(self.handle, value)

# Python type for struct consts.FWUpdBundleParams
class FWUpdBundleParams(go.GoClass):
	"""FW update bundle parameters.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.consts_FWUpdBundleParams_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.SubModule = args[0]
			if "SubModule" in kwargs:
				self.SubModule = kwargs["SubModule"]
			if  1 < len(args):
				self.ModuleType = args[1]
			if "ModuleType" in kwargs:
				self.ModuleType = kwargs["ModuleType"]
			if  2 < len(args):
				self.ModuleConfig = args[2]
			if "ModuleConfig" in kwargs:
				self.ModuleConfig = kwargs["ModuleConfig"]
			if  3 < len(args):
				self.BoardRevision = args[3]
			if "BoardRevision" in kwargs:
				self.BoardRevision = kwargs["BoardRevision"]
			if  4 < len(args):
				self.CPUType = args[4]
			if "CPUType" in kwargs:
				self.CPUType = kwargs["CPUType"]
			if  5 < len(args):
				self.FWType = args[5]
			if "FWType" in kwargs:
				self.FWType = kwargs["FWType"]
			if  6 < len(args):
				self.FWVerMaj = args[6]
			if "FWVerMaj" in kwargs:
				self.FWVerMaj = kwargs["FWVerMaj"]
			if  7 < len(args):
				self.FWVerMin = args[7]
			if "FWVerMin" in kwargs:
				self.FWVerMin = kwargs["FWVerMin"]
			if  8 < len(args):
				self.Flags = args[8]
			if "Flags" in kwargs:
				self.Flags = kwargs["Flags"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.FWUpdBundleParams{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'consts.FWUpdBundleParams ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SubModule(self):
		return _pygs.consts_FWUpdBundleParams_SubModule_Get(self.handle)
	@SubModule.setter
	def SubModule(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_SubModule_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_SubModule_Set(self.handle, value)
	@property
	def ModuleType(self):
		return _pygs.consts_FWUpdBundleParams_ModuleType_Get(self.handle)
	@ModuleType.setter
	def ModuleType(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_ModuleType_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_ModuleType_Set(self.handle, value)
	@property
	def ModuleConfig(self):
		return _pygs.consts_FWUpdBundleParams_ModuleConfig_Get(self.handle)
	@ModuleConfig.setter
	def ModuleConfig(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_ModuleConfig_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_ModuleConfig_Set(self.handle, value)
	@property
	def BoardRevision(self):
		return _pygs.consts_FWUpdBundleParams_BoardRevision_Get(self.handle)
	@BoardRevision.setter
	def BoardRevision(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_BoardRevision_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_BoardRevision_Set(self.handle, value)
	@property
	def CPUType(self):
		return _pygs.consts_FWUpdBundleParams_CPUType_Get(self.handle)
	@CPUType.setter
	def CPUType(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_CPUType_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_CPUType_Set(self.handle, value)
	@property
	def FWType(self):
		return _pygs.consts_FWUpdBundleParams_FWType_Get(self.handle)
	@FWType.setter
	def FWType(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_FWType_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_FWType_Set(self.handle, value)
	@property
	def FWVerMaj(self):
		return _pygs.consts_FWUpdBundleParams_FWVerMaj_Get(self.handle)
	@FWVerMaj.setter
	def FWVerMaj(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_FWVerMaj_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_FWVerMaj_Set(self.handle, value)
	@property
	def FWVerMin(self):
		return _pygs.consts_FWUpdBundleParams_FWVerMin_Get(self.handle)
	@FWVerMin.setter
	def FWVerMin(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_FWVerMin_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_FWVerMin_Set(self.handle, value)
	@property
	def Flags(self):
		return _pygs.consts_FWUpdBundleParams_Flags_Get(self.handle)
	@Flags.setter
	def Flags(self, value):
		if isinstance(value, go.GoClass):
			_pygs.consts_FWUpdBundleParams_Flags_Set(self.handle, value.handle)
		else:
			_pygs.consts_FWUpdBundleParams_Flags_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---

# Python type for map consts.AddressMap
class AddressMap(go.GoClass):
	"""Map of addresses to connect to. Used in GS configuration.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.consts_AddressMap_CTor()
			_pygs.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('consts_AddressMap.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pygs.consts_AddressMap_set(self.handle, k, v)
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		s = 'pygs.consts_AddressMap len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pygs.consts_AddressMap({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pygs.consts_AddressMap_len(self.handle)
	def __getitem__(self, key):
		return _pygs.consts_AddressMap_elem(self.handle, key)
	def __setitem__(self, key, value):
		_pygs.consts_AddressMap_set(self.handle, key, value)
	def __delitem__(self, key):
		return _pygs.consts_AddressMap_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_pygs.consts_AddressMap_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pygs.consts_AddressMap_contains(self.handle, key)
	def Add(self, val, goRun=False):
		"""Add(str val) 
		
		Add a new address to the map
		"""
		_pygs.consts_AddressMap_Add(self.handle, val, goRun)
	def MarshalYAML(self):
		"""MarshalYAML() object, str
		
		Marshal the map to a string.
		"""
		return any(handle=_pygs.consts_AddressMap_MarshalYAML(self.handle))
	def UnmarshalYAML(self, value):
		"""UnmarshalYAML(object value) str
		
		Initialize the AddressMap from a string.
		"""
		return _pygs.consts_AddressMap_UnmarshalYAML(self.handle, value.handle)


# ---- Constructors ---


# ---- Functions ---


