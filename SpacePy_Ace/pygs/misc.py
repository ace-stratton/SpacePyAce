
# python wrapper for package gitlab.endurosatlab.com/ground_station/go-comms/pkg/misc within overall package pygs
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy.exe build -build-tags=dbg_log with_wire_only -no-make -output=art\spacepy-windows-amd64 .\pygs ..\pkg\gs ..\pkg\consts ..\pkg\misc ..\internal\event_notifier

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _pygs
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pygs import misc
# and then refer to everything using misc. prefix
# packages imported by this package listed below:

from . import consts



# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
Msp430CrcDataBlockSize = 1000


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct misc.Msp430UpdateHeader
class Msp430UpdateHeader(go.GoClass):
	"""The MSP430 firmware update header\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pygs.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pygs.IncRef(self.handle)
		else:
			self.handle = _pygs.misc_Msp430UpdateHeader_CTor()
			_pygs.IncRef(self.handle)
			if  0 < len(args):
				self.CRCBlockSize = args[0]
			if "CRCBlockSize" in kwargs:
				self.CRCBlockSize = kwargs["CRCBlockSize"]
			if  1 < len(args):
				self.UpdateSize = args[1]
			if "UpdateSize" in kwargs:
				self.UpdateSize = kwargs["UpdateSize"]
	def __del__(self):
		_pygs.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'misc.Msp430UpdateHeader{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'misc.Msp430UpdateHeader ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def CRCBlockSize(self):
		return _pygs.misc_Msp430UpdateHeader_CRCBlockSize_Get(self.handle)
	@CRCBlockSize.setter
	def CRCBlockSize(self, value):
		if isinstance(value, go.GoClass):
			_pygs.misc_Msp430UpdateHeader_CRCBlockSize_Set(self.handle, value.handle)
		else:
			_pygs.misc_Msp430UpdateHeader_CRCBlockSize_Set(self.handle, value)
	@property
	def UpdateSize(self):
		return _pygs.misc_Msp430UpdateHeader_UpdateSize_Get(self.handle)
	@UpdateSize.setter
	def UpdateSize(self, value):
		if isinstance(value, go.GoClass):
			_pygs.misc_Msp430UpdateHeader_UpdateSize_Set(self.handle, value.handle)
		else:
			_pygs.misc_Msp430UpdateHeader_UpdateSize_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def FWUpdPrepareBinaryPayload(payload, moduleType, subModule, flags, aesKey, aesIV):
	"""FWUpdPrepareBinaryPayload([]int payload, int moduleType, int subModule, long flags, []int aesKey, []int aesIV) []int res, str err
	
	Prepares a firmware update for transmission from a firmware update binary.
	Payload is the firmware update binary.
	Module type is consts.ModuleTypeId.
	Sub-module is consts.SubModuleId.
	Flags is a bitmask of consts.FWUpdFlag.
	"""
	return go.Slice_byte(handle=_pygs.misc_FWUpdPrepareBinaryPayload(payload.handle, moduleType, subModule, flags, aesKey.handle, aesIV.handle))
def FWUpdPrepareBundlePayload(payload):
	"""FWUpdPrepareBundlePayload([]int payload) []int res
	
	Prepares a firmware update for transmission from a firmware update bundle. Strips the file transport header.
	Payload is the firmware update bundle.
	"""
	return go.Slice_byte(handle=_pygs.misc_FWUpdPrepareBundlePayload(payload.handle))
def RFChangeAESKey(aesKey):
	"""RFChangeAESKey([]int aesKey) []int
	
	Serializes a special data packet to write to esrfcfg connection for changing the AES key.
	"""
	return go.Slice_byte(handle=_pygs.misc_RFChangeAESKey(aesKey.handle))
def RFConfigChangeFreq(uplinkFreq, downlinkFreq, rfMode, isIntFrac):
	"""RFConfigChangeFreq(long uplinkFreq, long downlinkFreq, int rfMode, bool isIntFrac) []int
	
	Serializes a special data packet to write to esrfcfg connection for changing the radio frequency.
	isIntFrac specifies if the frequencies should be serialized in the special UHF RF chip format.
	"""
	return go.Slice_byte(handle=_pygs.misc_RFConfigChangeFreq(uplinkFreq, downlinkFreq, rfMode, isIntFrac))
def RFConfigChangeRadioMode(radioMode):
	"""RFConfigChangeRadioMode(int radioMode) []int
	
	Serializes a special data packet to write to esrfcfg connection for changing the radio mode.
	"""
	return go.Slice_byte(handle=_pygs.misc_RFConfigChangeRadioMode(radioMode))
def RFConfigInit(uplinkFreq, downlinkFreq, rfMode, radioMode, isIntFrac, encrypted):
	"""RFConfigInit(long uplinkFreq, long downlinkFreq, int rfMode, int radioMode, bool isIntFrac, bool encrypted) []int
	
	Serializes a special data packet to write to esrfcfg connection for initializing the radio.
	isIntFrac specifies if the frequencies should be serialized in the special UHF RF chip format.
	"""
	return go.Slice_byte(handle=_pygs.misc_RFConfigInit(uplinkFreq, downlinkFreq, rfMode, radioMode, isIntFrac, encrypted))


